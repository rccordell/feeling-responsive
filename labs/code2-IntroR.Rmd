---
title: "Intro to R"
author: "Ryan Cordell"
date: "2017-01-23"
output: html_document
---

# Start a New R Project

The first thing we'll do (likely before you even read these words) is start a new R project for this class. You can either select an existing directory—perhaps the one where you've saved the exercise files—or create a new one. You'll be saving all of your work for the semester here. In fact, I would recommend you create a master folder, named whatever you like, with subfolders named:

+ `exercises`: into which you can save the RMD files I will provide for each coding session
+ `fieldbooks`: into which you can create your own RMD files for your fieldbook submissions
+ `data`: into which you can save data files when we use them for later labs. 

For each coding session I will provide an RMD file like this one with instructions and sample code. You can copy the code from this website into your own R Markdown document, but you will have a much easier time following along if you [download the RMD file](https://www.dropbox.com/s/8q0kvuv7vhw4xhh/code2-IntroR.Rmd?dl=0) (save it in that `exercises` folder you created) and open it in R studio.

# R Markdown

This is an [R Markdown document](http://rmarkdown.rstudio.com/). R Markdown blends the markdown conventions you are learning in this class with a few customizations that let you embed snippets of code, as well as any outputs (e.g. graphs, maps) produced by that code into Markdown documents. This lets you weave together prose and code, so your readers can see the technical aspects of your work while reading about their interpretive significance. If you view this document on the course website you can see how the markdown syntax translates for presentation on the web. If you use Wordpress, you can enable Markdown for composing posts and pages by installing the Jetpack plugin.

# Running Code

As an RMD file, however, this is more than a flat text document: it's a program that you can run in RStudio. R Markdown allows you to embed executable code into your writing. If you click the 'run' arrow in the gray box below, the code will run. You should see the results in your console window. Try that now.

```{r}
2+2
5*32
10^10
```

As in most programming languages, you can do math in R: Charles Babbage would marvel!

In addition to using the run buttons above, you can also run R code *one line* at a time by putting your cursor on the line and hitting `command-return` (on a Mac), `control-return`(in Windows or Linux). If I don't use the R Markdown syntax to make an executable code block (by surrounding the code with three backticks and including the {r} designator) then you'll have to run the code using `command-return`. When you work with regular R documents—without the markdown—this will be the primary way you run code. Try running this code by highlighting the line and hitting `command-return`/`control-return`/??:

plot(1:100,(1:100)^2)

One reason many folks love R is the ease with which you can create plots and other data visualizations using it. We'll learn more about those as this class progresses. Note that you can also run code by pasting or typing it directly into the console window. This runs the code but does not save it as part of your RMD or R file.

# Packages and Libraries

One of the greatest attractions of R is the robust community writing *R packages*: collections of functions, data, and documentation that extend the capabilities of base R. Think of them like plugins, extensions, or DLC, like you may have installed for other kinds of software, such as your internet browser. 

You can do a lot in base R, but packages make many tasks much easier, and knowing how to install them is essential. [Tidyverse](http://tidyverse.org/) isn't actually one package, but a collection of packages that share a common philosophy and work well together. The tidyverse packages are quite useful for working with dataframes, R's standard for tabular data like CSVs and TSVs, which are essential for most humanistic data analysis. 

To install an R package, you can either click Tools --> Install Packages or run code like the install function below. Usually you wouldn't write the `install.packages` function into a piece of code, because once a package is installed on your machine it doesn't have to be reinstalled. Trying installing the `tidyverse` package by copying the line below into your console and hitting enter. 

install.packages("tidyverse")

It may take a few minutes for all the `tidyverse` packages to install, but you should only need to install a given package once on a particular machine. In order to actually use packages in a given script, you must load them using the `library()` function. You will usually load all of the packages you wish to use in a given script at the beginning, so that the functions, objects, and help files of that package will be available to you as you work. While you don't have to install a package every time you want to use it, you will need to invoke its library at least once during each R work session. 

```{r}
library(tidyverse)
```

# Variables 

In this class we're not so much interested in using R for math; we're interested in using R to learn more about texts. Remember that Ada Lovelace thought the Analytical Engine "might act upon other things besides *number*," including language or music (quoted in Gleick, 116). With modern programming languages we can manipulate text with our machines and learn things about its structure that are hard to ascertain by reading alone, particularly for large collections of text.

So let's start doing just that, though for now we'll be using some small(ish) texts to better understand how R code operates rather than really trying to learn much new about the texts themselves. In our last class I was dismayed to realize almost none of you have read Herman Melville's short story, "Bartleby, the Scrivener,"" so let's start with it. The code below will read the text of "Bartleby" from Project Gutenberg into R's memory. 

```{r}
bartleby <- data_frame(text=read_file("http://www.gutenberg.org/cache/epub/11231/pg11231.txt"))
```

First, what is that word `bartleby` in the code above? It's a variable, which means that it stores data for use in later processing. While Babbage and Lovelace imagined storing variables on physical cards that could be then used as input for the next stage of computation, in R variables are stored in working memory and designated by the labels we assign them. The `<-` assigns the data to its right to the variable on its left. The data could be loaded from outside R, as we are doing here, or it could be the results of a process within R, such as the transformation of another variable. 

A note: we used `<-` to assign this variable, but you can use `=` to do the same, which is why the code below will do exactly what the code above did:

```{r}
bartleby = data_frame(text=read_file("http://www.gutenberg.org/cache/epub/11231/pg11231.txt"))
```

Essentially, this code is telling R to read the lines of text found at the URL and to put all that information into a variable called `bartleby` that we can then call up later on. This doesn't create a new file on your hard drive: it simply stores the information in working memory. If you were to quit R (without telling it to save your session), then the next time you loaded R you would need to rerun your code to this point in order to restore this variable. 

A few important but perhaps not obvious points about variables:

1. Their names are arbitrary. I could have called this variable `melville` or `novella` or `hotDog` (save using a few characters reserved for special uses in R; more on that anon). Folks have very different philosophies about naming variables, and the best practice often depends on the uses to which a particular bit of code might be put. If I were writing a general script for detecting text reuse in newspaper pages, the highly specific `bartleby` might not be the best choice. I might instead opt for `book` or something that makes the general meaning of that variable within the script plain.

2. Variables can be reassigned. You may have noticed that we loaded data twice, though with only slightly different settings, into the variable `bartleby`. Often you will transform your data and replace a variable with the transformed version, but you want to be careful when doing so. A variable holds the data you've assigned it until it is reassigned or until you quit R (that's not precisely right, but it's good enough for now). 

3. We assign data to variables so that we can easily invoke that data for various kinds of analyses and transformations. We'll see some of those in the following. 

This particular variable is a dataframe, which is how R stores tabular data (think of an excel spreadsheet). If you look in your "Global Environment" panel in R Studio, you should now see `bartleby` listed under "Data." That panel will list all of the variables and other data currently in memory that can be invoked in your scripts. You can click the little grid next to `bartleby` in order to load the data frame in a new window, or you could run this code to do the same:

```{r}
View(bartleby)
```

This is perhaps the simplest spreadsheet ever designed, with one column (titled "text") and one row. We'll get to more advanced dataframes later this semester. For now, however, if we wanted to look more closely at the "text" column we could run:

```{r}
View(bartleby$text)
```

What do you think all those `\r` and `\n` in the text represent? We can get rid of them with something like this:

```{r}
bartleby$text <- gsub("\r\n", " ", bartleby$text) 

View(bartleby$text)
```

# Functions

`readLines`, `view`, and `gsub` above are functions. A function is a bit hard to define, given the range of functions in R, but in brief: a function is a bundle of code that performs a specific task. The wide range of functions available in R (and its extensions, or "packages," which we will discuss soon) is one of the great strengths of the platform. Programmers have written code for a great many tasks, and by invoking that code you can build on their work rather than writing everything directly from scratch. 

Run the code below and look at the resulting dataframe (it should open automatically). Can you tell what the code did? Look more closely at the lines in the code block: what do you think each of those functions does, and how do they work together? Spend a few minutes with this and then we will talk through it together.

```{r}
words <- bartleby %>% 
  unnest_tokens(word, text) %>%
  count(word, sort = TRUE) %>%
  ungroup

View(words)
```

Importantly, think about what `words` means in this code. What changes did it make to your RStudio interface? Does it look like something we discussed earlier?

Perhaps we want to just look at words from "Bartleby, the Scrivener" that carry more semantic meaning. The code below just slightly modifies what we did above. Run the code below and then ask, what do you think the new operation is doing?

```{r}
words <- bartleby %>% 
  unnest_tokens(word, text) %>%
  anti_join(stop_words) %>%
  count(word, sort = TRUE) %>%
  ungroup

View(words)
```

In addition to words, R makes it very easy to count (and compare, &c.) other units of language, such as bigrams, trigrams, and so forth. Units of n-length words are called "Ngrams." When building an index of ngrams, each possible sequence of n words is recorded, as if a lens with a n-words-long aperture is sliding along the text, taking a snapshot at each position. Below we're counting units of 5 words from our short story:

```{r}
bartleby %>%
  unnest_tokens(ngram,text,token="ngrams",n=5) %>%
  count(ngram,sort=T) %>%
  View()
```

Does that phrase at the top of this list look familiar? Where have you encountered it before? What about the other phrases in this table? What do they suggest about the story (or, perhaps, about this particular edition of the story)?

Thinking about the code, however, notice that I've invoked the `View()` function in a different way in this code than in the code block above. How does this code behave differently from the code that produced `words`? 

Now, in the code box below, write a few lines of code that show the bigrams in "Bartleby" (bigrams are sequences of two words). You can copy, paste, and edit from the code above. 

```{r}


```

In addition to words, R makes it very easy to count (and compare, &c.) other units of language, such as bigrams, trigrams, and so forth. We can even plot this kind of data to see visually, as in the code below which plots which trigrams are most frequent in the story:

```{r}
bartleby %>%
  unnest_tokens(word,text,token="ngrams",n=3) %>%
  group_by(word) %>% 
  filter(n()>8) %>%
  ggplot() + 
  geom_bar(fill="red") + 
  aes(x=word) + 
  coord_flip()
```

# Fieldbook Assignment

Your fieldbook for coding session 2a-2b should be composed in RStudio, as a new RMD file (File --> New File --> R Markdown). You should include some of the code you found most interesting/enlightening/infuriating. You can copy and paste from the RMD files we used in class. Perhaps even try to tweak some of the code blocks to do new things. You can't break anything. If something goes wrong simply clear the environment (using that broom icon in the `Environment` pane) and start again. If something goes *really* wrong, re-download the files I provided and start again. Remember that when you run this code you're not making permanent changes to the actual data on the websites from which you imported it: you're bringing the data into the R environment where you can experiment and yes, even make mistakes. In your fieldbook, ruminate on the code and its relationship to some of the ideas in our readings, particularly the Gleick. Start thinking about how coding and writing could weave together. 